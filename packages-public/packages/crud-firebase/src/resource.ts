import { v4 as uuidv4 } from "uuid";
import { BigNumberish } from "./common.js";

/**
 * @interface ResourceQueryOptions to sort/order firebase query
 */
export interface ResourceQueryOptions {
    limit?: number;
    skip?: number;
    orderBy?: string;
    order?: "asc" | "desc";
}

/**
 * @type Default resource id is a simple id string that can be autogenerated as uuid
 */
export type ResourceIdDefault = { readonly id?: string };

/**
 * @type Resource id validators. Encode/decode id, validate id/data.
 * @template ResourceId Resource id params (some params may be optional if can be autogenerated)
 * @field encodeId validator takes (idParams | string) => encodes as string
 * @field decodeId validator takes (string) => decodes as idParams
 */
export interface ResourceIdValidators<ResourceId extends Record<string, any>> {
    encodeId: (idParams: string | ResourceId) => string;
    decodeId: (id: string) => Required<ResourceId>;
}

/**
 * @type Resource data validators. Validate data.
 * @template ResourceData Resource data
 * @field validateDataPartial validates Partial<ResourceData>. Used in where()/update(). All validated fields MUST be optional.
 * @field validateData validates ResourceData. Used in set() (defaults to validateDataPartial).  Some or all validated fields MAY be required.
 */
export interface ResourceDataValidators<ResourceData extends Record<string, any>> {
    validateDataPartial: (item: Partial<ResourceData>) => Partial<ResourceData>;
    validateData?: (item: ResourceData) => ResourceData;
}

/**
 * Default uuid id encoder. Id can be autogenerated.
 */
export function uuidEncodeId(idParams: string | { id?: string }) {
    return typeof idParams === "string" ? idParams : idParams.id ?? uuidv4();
}

export function uuidDecodeId(id: string) {
    return { id };
}

/**
 * Uniquely identifies a query collection.
 * Inspired to replicate the Firebase IndexedDB local cache structure.
 * - prefixPath: Prefix to reach subcollecion. For top-level collections, empty array.
 * - collectionGroup: Final collection group.
 *
 * In this way we can indentify collections, subcollections, and collection group queries.
 * - collection: { prefixPath: [], collectionGroup: "myCollection" }
 * - subcollection: { prefixPath: ["myCollection", "collection-1"], collectionGroup: "mySubcollection" }
 * - group query: { prefixPath: [], collectionGroup: "mySubcollection" }
 *
 */
export type FirebaseCollectionKey = { collectionGroup: string; prefixPath: string[] };

export type FirebaseQueryOp = "getAll" | "getWhere" | "getWhereCount" | "getWhereFirst";
export type FirebaseGetOp = "get" | "getOrNull" | "getOrUndefined" | "getBatch";
export type FirebaseWriteOp = "set" | "setBatch" | "update" | "updateBatch" | "delete" | "deleteBatch" | "deleteAll";
export type FirebaseUpsertOp = "getOrCreate" | "getWhereFirstOrCreate";
export type FirebaseIncrOp = "incrementStr" | "decrementStr" | "incrementNumber" | "decrementNumber";

/**
 * Common Query operations for a resource defined on a collection (eg. /users) or group collection (eg. /xxx/users).
 * Note: id-based access is NOT possible with collection groups. See `FirebaseResource` for more complete interface
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export interface FirebaseQueryResource<
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any>,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> {
    //validators
    validateDataPartial: (data: Partial<ResourceData>) => Partial<ResourceData>;
    //queries
    getAll: (options?: ResourceQueryOptions) => Promise<Resource[]>;
    getWhere: (filter: Partial<ResourceData>, options?: ResourceQueryOptions) => Promise<Resource[]>;
    getWhereCount: (filter: Partial<ResourceData>, options?: ResourceQueryOptions) => Promise<number>;
    getWhereFirst: (
        filter: Partial<ResourceData>,
        options?: Omit<ResourceQueryOptions, "limit">,
    ) => Promise<Resource | null>;
}

/**
 * Common CRUD operations for a resource defined on a static collection (eg. /users).
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export interface FirebaseResource<
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any> = ResourceIdDefault,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> extends FirebaseQueryResource<ResourceData, ResourceIdPartial, Resource> {
    collectionPath: string;
    //validators
    validateData: (data: ResourceData) => ResourceData;
    encodeId: (idParams: string | ResourceIdPartial) => string;
    decodeId: (id: string) => Required<ResourceIdPartial>;
    //queries
    get: (id: string | Required<ResourceIdPartial>) => Promise<Resource>;
    getOrNull: (id: string | Required<ResourceIdPartial>) => Promise<Resource | null>;
    /** @deprecated renamed to getOrNull */
    getOrUndefined: (id: string | Required<ResourceIdPartial>) => Promise<Resource | null>;
    getBatch: (ids: string[] | Required<ResourceIdPartial>[]) => Promise<(Resource | null)[]>;
    set: (item: ResourceIdPartial & ResourceData) => Promise<string>;
    setBatch: (items: (ResourceIdPartial & ResourceData)[]) => Promise<string[]>;
    getOrCreate: (id: string | Required<ResourceIdPartial>, initialValue: ResourceData) => Promise<Resource>;
    getWhereFirstOrCreate: (
        filter: Partial<ResourceData>,
        initialValue: ResourceIdPartial & ResourceData,
        options?: Omit<ResourceQueryOptions, "limit">,
    ) => Promise<Resource>;
    update: (item: Required<ResourceIdPartial> & Partial<ResourceData>) => Promise<void>;
    updateBatch: (item: (Required<ResourceIdPartial> & Partial<ResourceData>)[]) => Promise<void>;
    delete: (id: Required<ResourceIdPartial> | string) => Promise<void>;
    deleteBatch: (ids: Required<ResourceIdPartial>[] | string[]) => Promise<void>;
    deleteAll: () => Promise<void>;
    incrementStr: (id: Required<ResourceIdPartial> | string, path: string, value: BigNumberish) => Promise<void>;
    decrementStr: (id: Required<ResourceIdPartial> | string, path: string, value: BigNumberish) => Promise<void>;
    incrementNumber: (id: Required<ResourceIdPartial> | string, path: string, value: number) => Promise<void>;
    decrementNumber: (id: Required<ResourceIdPartial> | string, path: string, value: number) => Promise<void>;
}

/**
 * Additional options to initialize Firebase resource
 * @field lruCacheSize enable mnemonist LRUCache for get,getBatch
 * WARNING: Cache behaviour is NOT perfect right now and should ONLY be used with static models
 * Ignore caching for MOST models except if you stand to gain significant performance.
 *
 * It is reasonably robust
 *  - cache hits
 *      - basic reads: get, getOrUndefined
 *      - transactional reads: getOrCreate
 *      - TODO: getBatch not implemented
 *  - cache purge
 *      - basic writes: set, setBatch, update, updateBatch, deleteById, deleteBatch, deleteAll
 *      - transactional writes: incrementStr, incrementNumber, getWhereFirstOrCreate (implied)
 *      //TODO: Should queries purge cache?
 *      - queries (NOT IMPLEMENTED): Not really required as the types of models that are static will only be accessed by id
 */
export type FirebaseResourceOptions = {
    lruCacheSize?: number;
};

/**
 * Factory function for generating Firebase resource when dealing with subcollections.
 * @template CollectionId Subcollection Params
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export type FirebaseResourceFactory<
    CollectionId extends Record<string, any>,
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any> = ResourceIdDefault,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> = (params: CollectionId) => FirebaseResource<ResourceData, ResourceIdPartial, Resource>;
