import { v4 as uuidv4 } from "uuid";
import { Prettify, TypeEqual, AsEmptyRecord } from "@owlprotocol/utils/types";
import type { BigNumberish } from "./common.js";
import type { CollectionReference, DocumentData, DocumentReference, FirestoreSDK } from "./document.js";
import type { Query, QuerySnapshot } from "./query.js";
import type { CacheWithDelete } from "./cache.js";
import type { SetOptions } from "./types.js";

/**
 * @interface ResourceQueryOptions to sort/order firebase query
 */
export interface ResourceQueryOptions {
    limit?: number;
    skip?: number;
    orderBy?: string;
    order?: "asc" | "desc";
}

/**
 * @type Default resource id is a simple id string that can be autogenerated as uuid
 */
export type ResourceIdDefault = { readonly id?: string };

/**
 * @type Resource data validators. Validate data.
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template CollectionId Resource parent collection id
 * @template ResourceDataInput Resource input data passed to `encodeData`, defaults to ResourceData
 * @template ResourceDataEncoded Resource encoded data passed to `decodeData`, defaults to ResourceData
 * @field encodeId encode document id
 * @field encodeDataPartial encode partial document data. Used in where()/update(). All validated fields MUST be optional.
 * @field encodeData encode document data. Used in set() (defaults to encodeDataPartial).  Some or all validated fields MAY be required.
 * @field encodeParentDocId encode path to collection
 * @field decodedId decode document id
 * @field decodeData decode document data
 * @field decodeParentDocId decode path to collection
 */
export type ResourceDataValidators<
    ResourceData extends DocumentData,
    ResourceId extends Record<string, any>,
    CollectionId extends Record<string, any> = Record<string, never>,
    ResourceDataInput extends DocumentData = ResourceData,
    ResourceDataEncoded extends DocumentData = ResourceData,
> = {
    encodeId: (idParams: ResourceId) => string;
    encodeDataPartial?: (data: Partial<ResourceDataInput>) => Partial<ResourceDataEncoded>;
    encodeData?: (data: ResourceDataInput) => ResourceDataEncoded;
    encodeParentDocId?: (collectionIdParams: CollectionId) => string;
    decodeId: (id: string) => Required<ResourceId>;
    decodeData?: (data: ResourceDataEncoded) => ResourceData;
    decodeParentDocId?: (collectionId: string) => CollectionId;
};

/**
 * Default uuid id encoder. Id can be autogenerated.
 */
export function uuidEncodeId(idParams: { id?: string }) {
    return typeof idParams === "string" ? idParams : idParams.id ?? uuidv4();
}

export function uuidDecodeId(id: string) {
    return { id };
}

/**
 * Uniquely identifies a query collection.
 * Inspired to replicate the Firebase IndexedDB local cache structure.
 * - prefixPath: Prefix to reach subcollecion. For top-level collections, empty array.
 * - collectionGroup: Final collection group.
 *
 * In this way we can indentify collections, subcollections, and collection group queries.
 * - collection: { prefixPath: [], collectionGroup: "myCollection" }
 * - subcollection: { prefixPath: ["myCollection", "collection-1"], collectionGroup: "mySubcollection" }
 * - group query: { prefixPath: [], collectionGroup: "mySubcollection" }
 *
 */
export type FirebaseCollectionKey = { collectionGroup: string; prefixPath: string[] };

export type FirebaseQueryOp = "getAll" | "getWhere" | "getWhereCount" | "getWhereFirst";
export type FirebaseGetOp = "get" | "getOrNull" | "getBatch";
export type FirebaseWriteOp = "set" | "setBatch" | "update" | "updateBatch" | "delete" | "deleteBatch" | "deleteAll";
export type FirebaseUpsertOp = "getOrCreate" | "getWhereFirstOrCreate";
export type FirebaseIncrOp = "incrementStr" | "decrementStr" | "incrementNumber" | "decrementNumber";

/**
 * Common Query operations for a resource defined on a collection (eg. /users) or group collection (eg. /xxx/users).
 * Note: id-based access is NOT possible with collection groups. See `FirebaseResource` for more complete interface
 * @template SDK Firestore sdk type
 * @template ResourceData Resource data
 * @template ResourceId Resource id params (some params may be optional if can be autogenerated)
 * @template CollectionId Resource parent collection id
 * @template ResourceDataInput Resource input data passed to `encodeData`, defaults to ResourceData
 * @template ResourceDataEncoded Resource encoded data passed to `decodeData`, defaults to ResourceData
 * @template QueryFn Query function, can be a query or a query factory function
 * @template ResourceFilter Full resource filter CollectionId & Partial<ResourceDataInput>
 * @template Resource Full returned resource CollectionId & ResourceId & ResourceData
 * @template QSnapshot Full query snapshot type QuerySnapshot<SDK, ResourceDataEncoded>
 */

export interface FirebaseQueryResource<
    SDK extends FirestoreSDK,
    ResourceData extends DocumentData = DocumentData,
    ResourceId extends Record<string, any> = Record<string, any>,
    CollectionId extends Record<string, any> = Record<string, never>,
    ResourceDataInput extends DocumentData = ResourceData,
    ResourceDataEncoded extends DocumentData = ResourceData,
    QueryFn extends TypeEqual<CollectionId, Record<string, never>> extends true
        ? Query<SDK, ResourceDataEncoded> //undefined CollectionId, Query MUST be defined
        :
              | Query<SDK, ResourceDataEncoded> //defined CollectionId, for group queries, for group queruesm Query MAY be defined, despite CollectionId defined, therefore union with QueryFactory
              | ((collectionId: CollectionId) => Query<SDK, ResourceDataEncoded>) = TypeEqual<
        CollectionId,
        Record<string, never>
    > extends true
        ? Query<SDK, ResourceDataEncoded> //Default type, undefined CollectionId, Query MUST be defined
        : (collectionId: CollectionId) => Query<SDK, ResourceDataEncoded>, //Default type, defined CollectionId, QueryFactory
    ResourceFilter extends TypeEqual<QueryFn, Query<SDK, ResourceDataEncoded>> extends true
        ? Partial<ResourceDataInput> //defined Query, filter by ResourceDataInput
        : //defined QueryFactory, for group queries, CollectionId MAY be omitted, so we use Partial<CollectionId>
          Prettify<Partial<AsEmptyRecord<CollectionId>> & Partial<ResourceDataInput>> = TypeEqual<
        QueryFn,
        Query<SDK, ResourceDataEncoded>
    > extends true
        ? Partial<ResourceDataInput> //Default type, defined Query, filter by ResourceDataInput
        : Prettify<AsEmptyRecord<CollectionId> & Partial<ResourceDataInput>>, //Default type, defined QueryFactory, filter by CollectionId & ResourceDataInput
    Resource extends Prettify<AsEmptyRecord<CollectionId> & ResourceId & ResourceData> = Prettify<
        AsEmptyRecord<CollectionId> & ResourceId & ResourceData
    >,
    QSnapshot extends QuerySnapshot<SDK, ResourceDataEncoded> = QuerySnapshot<SDK, ResourceDataEncoded>,
> {
    //TODO: Remove this?, required for now for groupQuery path used in react-query
    //Same as getQuery
    query: QueryFn;
    //base query
    getCollectionIdQueryOptions(
        collectionIdOrOptions?: CollectionId | ResourceQueryOptions,
        optionsOrNoParam?: ResourceQueryOptions,
    ): { collectionId: CollectionId | undefined; options: ResourceQueryOptions | undefined };
    getQuery: (
        ...parameters: TypeEqual<QueryFn, Query<SDK, ResourceDataEncoded>> extends true
            ? []
            : [collectionId: CollectionId]
    ) => Query<SDK, ResourceDataEncoded>;
    getWhereQuery: (filter: ResourceFilter, options?: ResourceQueryOptions) => Query<SDK, ResourceDataEncoded>;
    //queries
    getAll: (
        ...parameters: TypeEqual<QueryFn, Query<SDK, ResourceDataEncoded>> extends true
            ? [options?: ResourceQueryOptions]
            : [collectionId: CollectionId, options?: ResourceQueryOptions]
    ) => Promise<Resource[]>;
    getAllSnapshot: (
        ...parameters: TypeEqual<QueryFn, Query<SDK, ResourceDataEncoded>> extends true
            ? [options?: ResourceQueryOptions]
            : [collectionId: CollectionId, options?: ResourceQueryOptions]
    ) => Promise<QSnapshot>;
    getWhere: (filter: ResourceFilter, options?: ResourceQueryOptions) => Promise<Resource[]>;
    getWhereSnapshot: (filter: ResourceFilter, options?: ResourceQueryOptions) => Promise<QSnapshot>;
    getWhereCount: (filter: ResourceFilter, options?: ResourceQueryOptions) => Promise<number>;
    getWhereFirst: (filter: ResourceFilter, options?: Omit<ResourceQueryOptions, "limit">) => Promise<Resource | null>;
}

/**
 * Common CRUD operations for a resource defined on a static collection (eg. /users).
 * @template SDK Firestore sdk type
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template CollectionId Resource parent collection id
 * @template ResourceDataInput Resource input data passed to `encodeData`, defaults to ResourceData
 * @template ResourceDataEncoded Resource encoded data passed to `decodeData`, defaults to ResourceData
 * @template CollectionFn Collection function, can be a collection or a collection factory function
 * @template QueryFn Query function, can be a query or a query factory function
 * @template ResourceFilter Full resource filter CollectionId & Partial<ResourceDataInput>
 * @template Resource Full returned resource CollectionId & Required<ResourceIdPartial> & ResourceData
 * @template ResourceIdFull Full resource id CollectionId & Required<ResourceIdPartial>
 * @template QSnapshot Full query snapshot type QuerySnapshot<SDK, ResourceDataEncoded>
 */
export interface FirebaseResource<
    SDK extends FirestoreSDK,
    ResourceData extends DocumentData = DocumentData,
    ResourceIdPartial extends Record<string, any> = Record<string, any>,
    CollectionId extends Record<string, any> = Record<string, never>,
    ResourceDataInput extends DocumentData = ResourceData,
    ResourceDataEncoded extends DocumentData = ResourceData,
    CollectionFn extends TypeEqual<CollectionId, Record<string, never>> extends true
        ? CollectionReference<SDK, ResourceDataEncoded> //undefined CollectionId, Collection MUST be defined
        : //defined CollectionId, CollectionFactory MUST be defined
          (collectionId: CollectionId) => CollectionReference<SDK, ResourceDataEncoded> = TypeEqual<
        CollectionId,
        Record<string, never>
    > extends true
        ? CollectionReference<SDK, ResourceDataEncoded> //Default type, undefined CollectionId, Collection MUST be defined
        : (collectionId: CollectionId) => CollectionReference<SDK, ResourceDataEncoded>, //Default type, defined CollectionId, CollectionFactory MUST be defined
    QueryFn extends TypeEqual<CollectionId, Record<string, never>> extends true
        ? Query<SDK, ResourceDataEncoded> //undefined CollectionId, Query MUST be defined
        : //defined CollectionId, QueryFactory MUST be defined
          (collectionId: CollectionId) => Query<SDK, ResourceDataEncoded> = TypeEqual<
        CollectionId,
        Record<string, never>
    > extends true
        ? Query<SDK, ResourceDataEncoded> //Default type, undefined CollectionId, Query MUST be defined
        : (collectionId: CollectionId) => Query<SDK, ResourceDataEncoded>, //Default type, defined CollectionId, QueryFactory MUST be defined
    ResourceFilter extends TypeEqual<QueryFn, Query<SDK, ResourceDataEncoded>> extends true
        ? Partial<ResourceDataInput> //defined Query, filter by ResourceDataInput
        : //defined QueryFactory, for group queries, CollectionId MAY be omitted, so we use Partial<CollectionId>
          Prettify<Partial<AsEmptyRecord<CollectionId>> & Partial<ResourceDataInput>> = TypeEqual<
        QueryFn,
        Query<SDK, ResourceDataEncoded>
    > extends true
        ? Partial<ResourceDataInput> //Default type, defined Query, filter by ResourceDataInput
        : Prettify<AsEmptyRecord<CollectionId> & Partial<ResourceDataInput>>, //Default type, defined QueryFactory, filter by CollectionId & ResourceDataInput
    Resource extends Prettify<AsEmptyRecord<CollectionId> & Required<ResourceIdPartial> & ResourceData> = Prettify<
        AsEmptyRecord<CollectionId> & Required<ResourceIdPartial> & ResourceData
    >,
    ResourceIdFull extends TypeEqual<CollectionFn, CollectionReference<SDK, ResourceDataEncoded>> extends true
        ? Required<ResourceIdPartial> //defined Collection, get by ResourceId
        : //defined CollectionFactory, get by CollectionId & ResourceId
          Prettify<AsEmptyRecord<CollectionId> & Required<ResourceIdPartial>> = TypeEqual<
        CollectionFn,
        CollectionReference<SDK, ResourceDataEncoded>
    > extends true
        ? Required<ResourceIdPartial> //defined Collection, get by ResourceId
        : //defined CollectionFactory, get by CollectionId & ResourceId
          Prettify<AsEmptyRecord<CollectionId> & Required<ResourceIdPartial>>,
    QSnapshot extends QuerySnapshot<SDK, ResourceDataEncoded> = QuerySnapshot<SDK, ResourceDataEncoded>,
> extends FirebaseQueryResource<
            SDK,
            ResourceData,
            Required<ResourceIdPartial>,
            CollectionId,
            ResourceDataInput,
            ResourceDataEncoded,
            QueryFn,
            ResourceFilter,
            Resource,
            QSnapshot
        >,
        ResourceDataValidators<ResourceData, ResourceIdPartial, CollectionId, ResourceDataInput, ResourceDataEncoded> {
    collection: (
        ...parameters: TypeEqual<CollectionFn, CollectionReference<SDK, ResourceDataEncoded>> extends true
            ? []
            : [collectionId: CollectionId]
    ) => CollectionReference<SDK, ResourceDataEncoded>;
    doc: (id: ResourceIdFull) => DocumentReference<SDK, ResourceDataEncoded>;
    cache: CacheWithDelete<string, Resource> | undefined;
    //queries
    get: (id: ResourceIdFull) => Promise<Resource>;
    getOrNull: (id: ResourceIdFull) => Promise<Resource | null>;
    getBatch: (ids: ResourceIdFull[]) => Promise<(Resource | null)[]>;
    set: {
        (item: Prettify<AsEmptyRecord<CollectionId> & ResourceIdPartial & ResourceDataInput>): Promise<string>;
        (item: Prettify<ResourceIdFull & Partial<ResourceDataInput>>, options: SetOptions): Promise<string>;
    };
    upsert: (item: Prettify<ResourceIdFull & ResourceDataInput>) => Promise<string>;
    setBatch: {
        (items: Prettify<AsEmptyRecord<CollectionId> & ResourceIdPartial & ResourceDataInput>[]): Promise<string[]>;
        (items: Prettify<ResourceIdFull & Partial<ResourceDataInput>>[], options: SetOptions): Promise<string[]>;
    };
    upsertBatch: (items: Prettify<ResourceIdFull & ResourceDataInput>[]) => Promise<string[]>;
    getOrCreate: (id: ResourceIdFull, initialValue: ResourceDataInput) => Promise<Resource>;
    getWhereFirstOrCreate: (
        filter: ResourceFilter,
        initialValue: Prettify<AsEmptyRecord<CollectionId> & ResourceIdPartial & ResourceDataInput>,
        options?: Omit<ResourceQueryOptions, "limit">,
    ) => Promise<Resource>;
    update: (item: Prettify<ResourceIdFull & Partial<ResourceDataInput>>) => Promise<void>;
    updateBatch: (item: Prettify<ResourceIdFull & Partial<ResourceDataInput>>[]) => Promise<void>;
    delete: (id: ResourceIdFull) => Promise<void>;
    deleteBatch: (ids: ResourceIdFull[]) => Promise<void>;
    deleteAll: (
        ...parameters: TypeEqual<CollectionFn, CollectionReference<SDK, ResourceDataEncoded>> extends true
            ? []
            : [collectionId: CollectionId]
    ) => Promise<void>;
    incrementStr: (id: ResourceIdFull, path: string, value: BigNumberish) => Promise<void>;
    decrementStr: (id: ResourceIdFull, path: string, value: BigNumberish) => Promise<void>;
    incrementNumber: (id: ResourceIdFull, path: string, value: number) => Promise<void>;
    decrementNumber: (id: ResourceIdFull, path: string, value: number) => Promise<void>;
}

/**
 * Additional options to initialize Firebase resource
 * @field lruCacheSize enable mnemonist LRUCache for get,getBatch
 * WARNING: Cache behaviour is NOT perfect right now and should ONLY be used with static models
 * Ignore caching for MOST models except if you stand to gain significant performance.
 *
 * It is reasonably robust
 *  - cache hits
 *      - basic reads: get, getOrNull
 *      - transactional reads: getOrCreate
 *      - TODO: getBatch not implemented
 *  - cache purge
 *      - basic writes: set, setBatch, update, updateBatch, deleteById, deleteBatch, deleteAll
 *      - transactional writes: incrementStr, incrementNumber, getWhereFirstOrCreate (implied)
 *      //TODO: Should queries purge cache?
 *      - queries (NOT IMPLEMENTED): Not really required as the types of models that are static will only be accessed by id
 */
export type FirebaseResourceOptions = {
    lruCacheSize?: number;
};
