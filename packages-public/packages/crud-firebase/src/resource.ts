import { BigNumberish } from "@ethersproject/bignumber";

/**
 * @interface ResourceQueryOptions to sort/order firebase query
 */
export interface ResourceQueryOptions {
    limit?: number;
    skip?: number;
    orderBy?: string;
    order?: "asc" | "desc";
}

/**
 * @type Default resource id is a simple id string that can be autogenerated as uuid
 */
export type ResourceIdDefault = { readonly id?: string };

/**
 * @type Resource id validators. Encode/decode id, validate id/data.
 * @template ResourceId Resource id params (some params may be optional if can be autogenerated)
 * @field encodeId validator takes (idParams | string) => encodes as string
 * @field decodeId validator takes (string) => decodes as idParams
 */
export interface ResourceIdValidators<ResourceId extends Record<string, any>> {
    encodeId: (idParams: string | ResourceId) => string;
    decodeId: (id: string) => Required<ResourceId>;
}

/**
 * @type Resource data validators. Validate data.
 * @template ResourceData Resource data
 * @field validateDataPartial validates Partial<ResourceData>. Used in where()/update(). All validated fields MUST be optional.
 * @field validateData validates ResourceData. Used in set() (defaults to validateDataPartial).  Some or all validated fields MAY be required.
 */
export interface ResourceDataValidators<ResourceData extends Record<string, any>> {
    validateDataPartial: (item: Partial<ResourceData>) => Partial<ResourceData>;
    validateData?: (item: ResourceData) => ResourceData;
}

/**
 * Default validators for model with `id` field with default as crypto.randomUUID()
 */
export const uuidEncodeDecode: ResourceIdValidators<ResourceIdDefault> = {
    encodeId(idParams: string | { id?: string }) {
        return typeof idParams === "string" ? idParams : idParams.id ?? crypto.randomUUID();
    },
    decodeId(id: string) {
        return { id };
    },
};

/**
 * Common Query operations for a resource defined on a collection (eg. /users) or group collection (eg. /xxx/users).
 * Note: id-based access is NOT possible with collection groups. See `FirebaseResource` for more complete interface
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export interface FirebaseQueryResource<
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any>,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> {
    getAll: (options?: ResourceQueryOptions) => Promise<Resource[]>;
    getWhere: (filter: Partial<ResourceData>, options?: ResourceQueryOptions) => Promise<Resource[]>;
    getWhereCount: (filter: Partial<ResourceData>, options?: ResourceQueryOptions) => Promise<number>;
    getWhereFirst: (
        filter: Partial<ResourceData>,
        options?: Omit<ResourceQueryOptions, "limit">,
    ) => Promise<Resource | undefined>;
}

/**
 * Common CRUD operations for a resource defined on a static collection (eg. /users).
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export interface FirebaseResource<
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any> = ResourceIdDefault,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> extends FirebaseQueryResource<ResourceData, ResourceIdPartial, Resource> {
    get: (id: string | Required<ResourceIdPartial>) => Promise<Resource>;
    getOrUndefined: (id: string | Required<ResourceIdPartial>) => Promise<Resource | undefined>;
    getBatch: (ids: string[] | Required<ResourceIdPartial>[]) => Promise<(Resource | undefined)[]>;
    set: (item: ResourceIdPartial & ResourceData) => Promise<string>;
    setBatch: (items: (ResourceIdPartial & ResourceData)[]) => Promise<string[]>;
    getOrCreate: (id: string | Required<ResourceIdPartial>, initialValue: ResourceData) => Promise<Resource>;
    getWhereFirstOrCreate: (
        filter: Partial<ResourceData>,
        initialValue: ResourceIdPartial & ResourceData,
        options?: Omit<ResourceQueryOptions, "limit">,
    ) => Promise<Resource>;
    update: (item: Required<ResourceIdPartial> & Partial<ResourceData>) => Promise<void>;
    updateBatch: (item: (Required<ResourceIdPartial> & Partial<ResourceData>)[]) => Promise<void>;
    delete: (id: Required<ResourceIdPartial> | string) => Promise<void>;
    deleteBatch: (ids: Required<ResourceIdPartial>[] | string[]) => Promise<void>;
    deleteAll: () => Promise<void>;
    incrementStr: (id: Required<ResourceIdPartial> | string, path: string, value: BigNumberish) => Promise<void>;
    decrementStr: (id: Required<ResourceIdPartial> | string, path: string, value: BigNumberish) => Promise<void>;
    incrementNumber: (id: Required<ResourceIdPartial> | string, path: string, value: number) => Promise<void>;
    decrementNumber: (id: Required<ResourceIdPartial> | string, path: string, value: number) => Promise<void>;
}

/**
 * Factory function for generating Firebase resource when dealing with subcollections.
 * @template CollectionId Subcollection Params
 * @template ResourceData Resource data
 * @template ResourceIdPartial Resource id params (some params may be optional if can be autogenerated)
 * @template Resource Full resource, join collection, data, & id
 */
export type FirebaseResourceFactory<
    CollectionId extends Record<string, NonNullable<any>>,
    ResourceData extends Record<string, any>,
    ResourceIdPartial extends Record<string, any> = ResourceIdDefault,
    Resource extends Required<ResourceIdPartial> & ResourceData = Required<ResourceIdPartial> & ResourceData,
> = (params: CollectionId) => FirebaseResource<ResourceData, ResourceIdPartial, Resource>;
