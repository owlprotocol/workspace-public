/***** Generics for Firebase Web CRUD *****/
import {
    CollectionReference,
    DocumentData,
    DocumentReference,
    DocumentSnapshot,
    Firestore,
    Query,
    QuerySnapshot,
    collection,
    limit,
    orderBy,
} from "firebase/firestore";
import { doc, query, where, QueryConstraint } from "firebase/firestore";
//@ts-expect-error
import { useFirestoreCollection, useFirestoreDoc, ObservableStatus } from "reactfire";
import { CrudValidators, QueryOptions, getIdParamsDefault, joinSorted } from "../crud.js";
import { getFirestoreUpdateData } from "../utils/getFirestoreUpdateData.js";

export function generateUUID({ id }: { id?: string }) {
    return {
        id: id ?? crypto.randomUUID(),
    };
}

/**
 * Firebase CRUD Wrappers. create, get, getAll, update, rdelete, deleteAll
 * @template Item Generic type for collection data (data stored in documents)
 * @template ItemIdPartial Generic type for collection id (used to compute document path). Fields can be optional but validateId function must specify auto-generation
 * @param firestore Firestore instance
 * @param collectionPath Collection path (eg. `/users`)
 * @param validators Validators for id and data.
 *      By default, id validation is configured for `{ id?: string }` structure where ids are autogenerated with crypto.randomUUID().
 *      By default, data validation omits `id` field.
 * @returns wrapper functions for access Firebase
 * @returns
 */
export function getFirebaseHooks<
    ItemData extends Record<string, any>,
    ItemIdPartial extends Record<string, any> = { readonly id: string },
>(
    firestore: Firestore,
    collectionPath: string,
    validators?: Omit<CrudValidators<ItemData, ItemIdPartial>, "validateData">,
) {
    type ItemId = Required<ItemIdPartial>;
    type Item = ItemId & ItemData;

    const {
        getId = joinSorted<ItemId>,
        getIdParams = getIdParamsDefault as unknown as (id: string) => ItemId,
        validateId = generateUUID as unknown as (idParams: ItemIdPartial) => ItemId,
    } = validators ?? {};

    const col = collection(firestore, collectionPath) as CollectionReference<ItemData>;

    const getDocRef = (id: ItemId | string): DocumentReference<ItemData, DocumentData> => {
        if (typeof id === "string") return doc(col, id);

        return doc(col, getId(validateId(id)));
    };

    /**
     * Get doc by id
     * @param id
     * @returns doc by id
     */
    const useGet = (
        id: ItemId | string | undefined,
    ): [Item | undefined, ObservableStatus<DocumentSnapshot<ItemData, DocumentData>>] => {
        //undefined | "" path breaks, we set it to empty
        const ref = getDocRef(id ?? "empty");
        const result = useFirestoreDoc(ref);
        const refSnapshot = result.data;
        const data = (refSnapshot ? { ...refSnapshot.data(), ...getIdParams(ref.id) } : undefined) as Item | undefined;

        return [data, result];
    };

    /**
     * Get all docs
     * @returns docs
     */
    const useGetAll = (): [Item[] | undefined, ObservableStatus<QuerySnapshot<ItemData, DocumentData>>] => {
        const result = useFirestoreCollection(col);
        const snapshot = result.data;
        const data = (
            snapshot
                ? //TODO: Remove any
                  snapshot.docs.map((d: any) => {
                      return { ...d.data(), ...getIdParams(d.id) };
                  })
                : undefined
        ) as Item[] | undefined;

        return [data, result];
    };

    /**
     * Returns filter query that can be used to get items, count the query or compose with additional queries.
     * @param filter, will try to match the key-value pairs of this object as `where(key, "==", value)` queries.
     *      For nested keys, this gets reformated as `where(key.subkey, "==", value)` similar as to the update function
     * @param options limit, orderBy, order
     * @returns firebase query object
     */
    const getWhereQuery = (filter: Partial<ItemData>, options?: QueryOptions): Query<ItemData, DocumentData> => {
        //TODO: Add validate data similar to web sdk
        const filterNested = getFirestoreUpdateData(filter);

        const queryFilterConstraints: QueryConstraint[] = Object.entries(filterNested).map(([key, value]) => {
            return where(key, "==", value);
        });
        if (options?.orderBy) {
            queryFilterConstraints.push(orderBy(options.orderBy, options.order ?? "asc"));
        }
        if (options?.limit) {
            queryFilterConstraints.push(limit(options.limit));
        }

        return query(col, ...queryFilterConstraints);
    };

    /**
     * Get docs that match filter
     * @param filter
     * @param options limit, orderBy, order
     * @returns docs
     */
    const useGetWhere = (
        filter: Partial<ItemData>,
        options?: QueryOptions,
    ): [Item[] | undefined, ObservableStatus<QuerySnapshot<ItemData, DocumentData>>] => {
        const result = useFirestoreCollection(getWhereQuery(filter, options));
        const snapshot = result.data;
        const data = (
            snapshot
                ? //TODO: Remove any
                  snapshot.docs.map((d: any) => {
                      return { ...d.data(), ...getIdParams(d.id) };
                  })
                : undefined
        ) as Item[] | undefined;

        return [data, result] as [Item[] | undefined, typeof result];
    };

    /**
     * Get docs that match filter
     * @param filter
     * @param options limit, orderBy, order
     * @returns docs
     */
    const useGetWhereFirst = (
        filter: Partial<ItemData>,
        options?: Omit<QueryOptions, "limit">,
    ): [Item | undefined, ObservableStatus<QuerySnapshot<ItemData, DocumentData>>] => {
        const [data, result] = useGetWhere(filter, { ...options, limit: 1 });

        return [data ? data[0] : undefined, result];
    };

    return {
        getWhereQuery,
        useGet,
        useGetAll,
        useGetWhere,
        useGetWhereFirst,
    };
}
