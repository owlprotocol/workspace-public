/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.DeployBeaconProxyDefaultResponse
import org.openapitools.client.models.DeployBeaconProxyRequest
import org.openapitools.client.models.DeployChainlinkAnyApiClientRequest
import org.openapitools.client.models.DeployERC1155MintableRequest
import org.openapitools.client.models.DeployERC20MintableRequest
import org.openapitools.client.models.DeployERC2981SetterRequest
import org.openapitools.client.models.DeployERC721MintableRequest
import org.openapitools.client.models.DeployTokenDnaRequest
import org.openapitools.client.models.DeployTokenURIBaseURIRequest
import org.openapitools.client.models.DeployTokenURIDnaRequest
import org.openapitools.client.models.DeployTokenURIRequest
import org.openapitools.client.models.DeployUpgradeableBeaconRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DeployApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://17a0-195-175-28-162.ngrok-free.app/api")
        }
    }

    /**
     * Deploy BeaconProxy
     * Deploys an instance of &#x60;BeaconProxy&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployBeaconProxyRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployBeaconProxy(networkId: kotlin.String = "80001", deployBeaconProxyRequest: DeployBeaconProxyRequest) : kotlin.Any {
        val localVarResponse = deployBeaconProxyWithHttpInfo(networkId = networkId, deployBeaconProxyRequest = deployBeaconProxyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy BeaconProxy
     * Deploys an instance of &#x60;BeaconProxy&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployBeaconProxyRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployBeaconProxyWithHttpInfo(networkId: kotlin.String, deployBeaconProxyRequest: DeployBeaconProxyRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployBeaconProxyRequestConfig(networkId = networkId, deployBeaconProxyRequest = deployBeaconProxyRequest)

        return request<DeployBeaconProxyRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployBeaconProxy
     *
     * @param networkId The network id (default to "80001")
     * @param deployBeaconProxyRequest 
     * @return RequestConfig
     */
    fun deployBeaconProxyRequestConfig(networkId: kotlin.String, deployBeaconProxyRequest: DeployBeaconProxyRequest) : RequestConfig<DeployBeaconProxyRequest> {
        val localVariableBody = deployBeaconProxyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/BeaconProxy".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ChainlinkAnyApiClient
     * Deploys an instance of &#x60;ChainlinkAnyApiClient&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployChainlinkAnyApiClientRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployChainlinkAnyApiClient(networkId: kotlin.String = "80001", deployChainlinkAnyApiClientRequest: DeployChainlinkAnyApiClientRequest) : kotlin.Any {
        val localVarResponse = deployChainlinkAnyApiClientWithHttpInfo(networkId = networkId, deployChainlinkAnyApiClientRequest = deployChainlinkAnyApiClientRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ChainlinkAnyApiClient
     * Deploys an instance of &#x60;ChainlinkAnyApiClient&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployChainlinkAnyApiClientRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployChainlinkAnyApiClientWithHttpInfo(networkId: kotlin.String, deployChainlinkAnyApiClientRequest: DeployChainlinkAnyApiClientRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployChainlinkAnyApiClientRequestConfig(networkId = networkId, deployChainlinkAnyApiClientRequest = deployChainlinkAnyApiClientRequest)

        return request<DeployChainlinkAnyApiClientRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployChainlinkAnyApiClient
     *
     * @param networkId The network id (default to "80001")
     * @param deployChainlinkAnyApiClientRequest 
     * @return RequestConfig
     */
    fun deployChainlinkAnyApiClientRequestConfig(networkId: kotlin.String, deployChainlinkAnyApiClientRequest: DeployChainlinkAnyApiClientRequest) : RequestConfig<DeployChainlinkAnyApiClientRequest> {
        val localVariableBody = deployChainlinkAnyApiClientRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ChainlinkAnyApiClient".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ERC1155Mintable
     * Deploys an instance of &#x60;ERC1155Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC1155MintableRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployERC1155Mintable(networkId: kotlin.String = "80001", deployERC1155MintableRequest: DeployERC1155MintableRequest) : kotlin.Any {
        val localVarResponse = deployERC1155MintableWithHttpInfo(networkId = networkId, deployERC1155MintableRequest = deployERC1155MintableRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ERC1155Mintable
     * Deploys an instance of &#x60;ERC1155Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC1155MintableRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployERC1155MintableWithHttpInfo(networkId: kotlin.String, deployERC1155MintableRequest: DeployERC1155MintableRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployERC1155MintableRequestConfig(networkId = networkId, deployERC1155MintableRequest = deployERC1155MintableRequest)

        return request<DeployERC1155MintableRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployERC1155Mintable
     *
     * @param networkId The network id (default to "80001")
     * @param deployERC1155MintableRequest 
     * @return RequestConfig
     */
    fun deployERC1155MintableRequestConfig(networkId: kotlin.String, deployERC1155MintableRequest: DeployERC1155MintableRequest) : RequestConfig<DeployERC1155MintableRequest> {
        val localVariableBody = deployERC1155MintableRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ERC1155Mintable".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ERC20Mintable
     * Deploys an instance of &#x60;ERC20Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC20MintableRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployERC20Mintable(networkId: kotlin.String = "80001", deployERC20MintableRequest: DeployERC20MintableRequest) : kotlin.Any {
        val localVarResponse = deployERC20MintableWithHttpInfo(networkId = networkId, deployERC20MintableRequest = deployERC20MintableRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ERC20Mintable
     * Deploys an instance of &#x60;ERC20Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC20MintableRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployERC20MintableWithHttpInfo(networkId: kotlin.String, deployERC20MintableRequest: DeployERC20MintableRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployERC20MintableRequestConfig(networkId = networkId, deployERC20MintableRequest = deployERC20MintableRequest)

        return request<DeployERC20MintableRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployERC20Mintable
     *
     * @param networkId The network id (default to "80001")
     * @param deployERC20MintableRequest 
     * @return RequestConfig
     */
    fun deployERC20MintableRequestConfig(networkId: kotlin.String, deployERC20MintableRequest: DeployERC20MintableRequest) : RequestConfig<DeployERC20MintableRequest> {
        val localVariableBody = deployERC20MintableRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ERC20Mintable".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ERC2981Setter
     * Deploys an instance of &#x60;ERC2981Setter&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC2981SetterRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployERC2981Setter(networkId: kotlin.String = "80001", deployERC2981SetterRequest: DeployERC2981SetterRequest) : kotlin.Any {
        val localVarResponse = deployERC2981SetterWithHttpInfo(networkId = networkId, deployERC2981SetterRequest = deployERC2981SetterRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ERC2981Setter
     * Deploys an instance of &#x60;ERC2981Setter&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC2981SetterRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployERC2981SetterWithHttpInfo(networkId: kotlin.String, deployERC2981SetterRequest: DeployERC2981SetterRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployERC2981SetterRequestConfig(networkId = networkId, deployERC2981SetterRequest = deployERC2981SetterRequest)

        return request<DeployERC2981SetterRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployERC2981Setter
     *
     * @param networkId The network id (default to "80001")
     * @param deployERC2981SetterRequest 
     * @return RequestConfig
     */
    fun deployERC2981SetterRequestConfig(networkId: kotlin.String, deployERC2981SetterRequest: DeployERC2981SetterRequest) : RequestConfig<DeployERC2981SetterRequest> {
        val localVariableBody = deployERC2981SetterRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ERC2981Setter".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ERC721Mintable
     * Deploys an instance of &#x60;ERC721Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployERC721Mintable(networkId: kotlin.String = "80001", deployERC721MintableRequest: DeployERC721MintableRequest) : kotlin.Any {
        val localVarResponse = deployERC721MintableWithHttpInfo(networkId = networkId, deployERC721MintableRequest = deployERC721MintableRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ERC721Mintable
     * Deploys an instance of &#x60;ERC721Mintable&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployERC721MintableWithHttpInfo(networkId: kotlin.String, deployERC721MintableRequest: DeployERC721MintableRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployERC721MintableRequestConfig(networkId = networkId, deployERC721MintableRequest = deployERC721MintableRequest)

        return request<DeployERC721MintableRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployERC721Mintable
     *
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return RequestConfig
     */
    fun deployERC721MintableRequestConfig(networkId: kotlin.String, deployERC721MintableRequest: DeployERC721MintableRequest) : RequestConfig<DeployERC721MintableRequest> {
        val localVariableBody = deployERC721MintableRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ERC721Mintable".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy ERC721MintableAutoId
     * Deploys an instance of &#x60;ERC721MintableAutoId&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployERC721MintableAutoId(networkId: kotlin.String = "80001", deployERC721MintableRequest: DeployERC721MintableRequest) : kotlin.Any {
        val localVarResponse = deployERC721MintableAutoIdWithHttpInfo(networkId = networkId, deployERC721MintableRequest = deployERC721MintableRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy ERC721MintableAutoId
     * Deploys an instance of &#x60;ERC721MintableAutoId&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployERC721MintableAutoIdWithHttpInfo(networkId: kotlin.String, deployERC721MintableRequest: DeployERC721MintableRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployERC721MintableAutoIdRequestConfig(networkId = networkId, deployERC721MintableRequest = deployERC721MintableRequest)

        return request<DeployERC721MintableRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployERC721MintableAutoId
     *
     * @param networkId The network id (default to "80001")
     * @param deployERC721MintableRequest 
     * @return RequestConfig
     */
    fun deployERC721MintableAutoIdRequestConfig(networkId: kotlin.String, deployERC721MintableRequest: DeployERC721MintableRequest) : RequestConfig<DeployERC721MintableRequest> {
        val localVariableBody = deployERC721MintableRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/ERC721MintableAutoId".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy TokenDna
     * Deploys an instance of &#x60;TokenDna&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenDnaRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployTokenDna(networkId: kotlin.String = "80001", deployTokenDnaRequest: DeployTokenDnaRequest) : kotlin.Any {
        val localVarResponse = deployTokenDnaWithHttpInfo(networkId = networkId, deployTokenDnaRequest = deployTokenDnaRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy TokenDna
     * Deploys an instance of &#x60;TokenDna&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenDnaRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployTokenDnaWithHttpInfo(networkId: kotlin.String, deployTokenDnaRequest: DeployTokenDnaRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployTokenDnaRequestConfig(networkId = networkId, deployTokenDnaRequest = deployTokenDnaRequest)

        return request<DeployTokenDnaRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployTokenDna
     *
     * @param networkId The network id (default to "80001")
     * @param deployTokenDnaRequest 
     * @return RequestConfig
     */
    fun deployTokenDnaRequestConfig(networkId: kotlin.String, deployTokenDnaRequest: DeployTokenDnaRequest) : RequestConfig<DeployTokenDnaRequest> {
        val localVariableBody = deployTokenDnaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/TokenDna".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy TokenURI
     * Deploys an instance of &#x60;TokenURI&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployTokenURI(networkId: kotlin.String = "80001", deployTokenURIRequest: DeployTokenURIRequest) : kotlin.Any {
        val localVarResponse = deployTokenURIWithHttpInfo(networkId = networkId, deployTokenURIRequest = deployTokenURIRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy TokenURI
     * Deploys an instance of &#x60;TokenURI&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployTokenURIWithHttpInfo(networkId: kotlin.String, deployTokenURIRequest: DeployTokenURIRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployTokenURIRequestConfig(networkId = networkId, deployTokenURIRequest = deployTokenURIRequest)

        return request<DeployTokenURIRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployTokenURI
     *
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIRequest 
     * @return RequestConfig
     */
    fun deployTokenURIRequestConfig(networkId: kotlin.String, deployTokenURIRequest: DeployTokenURIRequest) : RequestConfig<DeployTokenURIRequest> {
        val localVariableBody = deployTokenURIRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/TokenURI".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy TokenURIBaseURI
     * Deploys an instance of &#x60;TokenURIBaseURI&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIBaseURIRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployTokenURIBaseURI(networkId: kotlin.String = "80001", deployTokenURIBaseURIRequest: DeployTokenURIBaseURIRequest) : kotlin.Any {
        val localVarResponse = deployTokenURIBaseURIWithHttpInfo(networkId = networkId, deployTokenURIBaseURIRequest = deployTokenURIBaseURIRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy TokenURIBaseURI
     * Deploys an instance of &#x60;TokenURIBaseURI&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIBaseURIRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployTokenURIBaseURIWithHttpInfo(networkId: kotlin.String, deployTokenURIBaseURIRequest: DeployTokenURIBaseURIRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployTokenURIBaseURIRequestConfig(networkId = networkId, deployTokenURIBaseURIRequest = deployTokenURIBaseURIRequest)

        return request<DeployTokenURIBaseURIRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployTokenURIBaseURI
     *
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIBaseURIRequest 
     * @return RequestConfig
     */
    fun deployTokenURIBaseURIRequestConfig(networkId: kotlin.String, deployTokenURIBaseURIRequest: DeployTokenURIBaseURIRequest) : RequestConfig<DeployTokenURIBaseURIRequest> {
        val localVariableBody = deployTokenURIBaseURIRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/TokenURIBaseURI".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy TokenURIDna
     * Deploys an instance of &#x60;TokenURIDna&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIDnaRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployTokenURIDna(networkId: kotlin.String = "80001", deployTokenURIDnaRequest: DeployTokenURIDnaRequest) : kotlin.Any {
        val localVarResponse = deployTokenURIDnaWithHttpInfo(networkId = networkId, deployTokenURIDnaRequest = deployTokenURIDnaRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy TokenURIDna
     * Deploys an instance of &#x60;TokenURIDna&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIDnaRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployTokenURIDnaWithHttpInfo(networkId: kotlin.String, deployTokenURIDnaRequest: DeployTokenURIDnaRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployTokenURIDnaRequestConfig(networkId = networkId, deployTokenURIDnaRequest = deployTokenURIDnaRequest)

        return request<DeployTokenURIDnaRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployTokenURIDna
     *
     * @param networkId The network id (default to "80001")
     * @param deployTokenURIDnaRequest 
     * @return RequestConfig
     */
    fun deployTokenURIDnaRequestConfig(networkId: kotlin.String, deployTokenURIDnaRequest: DeployTokenURIDnaRequest) : RequestConfig<DeployTokenURIDnaRequest> {
        val localVariableBody = deployTokenURIDnaRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/TokenURIDna".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Deploy UpgradeableBeacon
     * Deploys an instance of &#x60;UpgradeableBeacon&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployUpgradeableBeaconRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deployUpgradeableBeacon(networkId: kotlin.String = "80001", deployUpgradeableBeaconRequest: DeployUpgradeableBeaconRequest) : kotlin.Any {
        val localVarResponse = deployUpgradeableBeaconWithHttpInfo(networkId = networkId, deployUpgradeableBeaconRequest = deployUpgradeableBeaconRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deploy UpgradeableBeacon
     * Deploys an instance of &#x60;UpgradeableBeacon&#x60;
     * @param networkId The network id (default to "80001")
     * @param deployUpgradeableBeaconRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deployUpgradeableBeaconWithHttpInfo(networkId: kotlin.String, deployUpgradeableBeaconRequest: DeployUpgradeableBeaconRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deployUpgradeableBeaconRequestConfig(networkId = networkId, deployUpgradeableBeaconRequest = deployUpgradeableBeaconRequest)

        return request<DeployUpgradeableBeaconRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deployUpgradeableBeacon
     *
     * @param networkId The network id (default to "80001")
     * @param deployUpgradeableBeaconRequest 
     * @return RequestConfig
     */
    fun deployUpgradeableBeaconRequestConfig(networkId: kotlin.String, deployUpgradeableBeaconRequest: DeployUpgradeableBeaconRequest) : RequestConfig<DeployUpgradeableBeaconRequest> {
        val localVariableBody = deployUpgradeableBeaconRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/deploy/UpgradeableBeacon".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
