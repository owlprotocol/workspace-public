/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.DeployBeaconProxyDefaultResponse
import org.openapitools.client.models.InterfacesIBeaconImplementationRequest
import org.openapitools.client.models.InterfacesIERC1820GetManagerRequest
import org.openapitools.client.models.InterfacesIERC20Allowance200Response
import org.openapitools.client.models.InterfacesIERC20AllowanceRequest
import org.openapitools.client.models.InterfacesIERC20Approve200Response
import org.openapitools.client.models.InterfacesIERC20ApproveRequest
import org.openapitools.client.models.InterfacesIERC20BalanceOf200Response
import org.openapitools.client.models.InterfacesIERC20TotalSupply200Response
import org.openapitools.client.models.InterfacesIERC20Transfer200Response
import org.openapitools.client.models.InterfacesIERC20TransferFrom200Response
import org.openapitools.client.models.InterfacesIERC20TransferFromRequest
import org.openapitools.client.models.InterfacesIERC20TransferRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class IERC20Api(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://17a0-195-175-28-162.ngrok-free.app/api")
        }
    }

    /**
     * IERC20.allowance
     * Read &#x60;allowance(owner,spender)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return InterfacesIERC20Allowance200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20Allowance(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : InterfacesIERC20Allowance200Response {
        val localVarResponse = interfacesIERC20AllowanceWithHttpInfo(networkId = networkId, address = address, interfacesIERC20AllowanceRequest = interfacesIERC20AllowanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Allowance200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.allowance
     * Read &#x60;allowance(owner,spender)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return ApiResponse<InterfacesIERC20Allowance200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20AllowanceWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : ApiResponse<InterfacesIERC20Allowance200Response?> {
        val localVariableConfig = interfacesIERC20AllowanceRequestConfig(networkId = networkId, address = address, interfacesIERC20AllowanceRequest = interfacesIERC20AllowanceRequest)

        return request<InterfacesIERC20AllowanceRequest, InterfacesIERC20Allowance200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20Allowance
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20AllowanceRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : RequestConfig<InterfacesIERC20AllowanceRequest> {
        val localVariableBody = interfacesIERC20AllowanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/read/{address}/allowance".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20.approve
     * Write &#x60;approve(spender,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return InterfacesIERC20Approve200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20Approve(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : InterfacesIERC20Approve200Response {
        val localVarResponse = interfacesIERC20ApproveWithHttpInfo(networkId = networkId, address = address, interfacesIERC20ApproveRequest = interfacesIERC20ApproveRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Approve200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.approve
     * Write &#x60;approve(spender,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return ApiResponse<InterfacesIERC20Approve200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20ApproveWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : ApiResponse<InterfacesIERC20Approve200Response?> {
        val localVariableConfig = interfacesIERC20ApproveRequestConfig(networkId = networkId, address = address, interfacesIERC20ApproveRequest = interfacesIERC20ApproveRequest)

        return request<InterfacesIERC20ApproveRequest, InterfacesIERC20Approve200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20Approve
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20ApproveRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : RequestConfig<InterfacesIERC20ApproveRequest> {
        val localVariableBody = interfacesIERC20ApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/write/{address}/approve".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20.balanceOf
     * Read &#x60;balanceOf(account)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return InterfacesIERC20BalanceOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20BalanceOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : InterfacesIERC20BalanceOf200Response {
        val localVarResponse = interfacesIERC20BalanceOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC1820GetManagerRequest = interfacesIERC1820GetManagerRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20BalanceOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.balanceOf
     * Read &#x60;balanceOf(account)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return ApiResponse<InterfacesIERC20BalanceOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20BalanceOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : ApiResponse<InterfacesIERC20BalanceOf200Response?> {
        val localVariableConfig = interfacesIERC20BalanceOfRequestConfig(networkId = networkId, address = address, interfacesIERC1820GetManagerRequest = interfacesIERC1820GetManagerRequest)

        return request<InterfacesIERC1820GetManagerRequest, InterfacesIERC20BalanceOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20BalanceOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20BalanceOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : RequestConfig<InterfacesIERC1820GetManagerRequest> {
        val localVariableBody = interfacesIERC1820GetManagerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/read/{address}/balanceOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20.totalSupply
     * Read &#x60;totalSupply()&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIERC20TotalSupply200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20TotalSupply(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIERC20TotalSupply200Response {
        val localVarResponse = interfacesIERC20TotalSupplyWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20TotalSupply200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.totalSupply
     * Read &#x60;totalSupply()&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIERC20TotalSupply200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20TotalSupplyWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIERC20TotalSupply200Response?> {
        val localVariableConfig = interfacesIERC20TotalSupplyRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIERC20TotalSupply200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20TotalSupply
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20TotalSupplyRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/read/{address}/totalSupply".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20.transfer
     * Write &#x60;transfer(to,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return InterfacesIERC20Transfer200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20Transfer(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : InterfacesIERC20Transfer200Response {
        val localVarResponse = interfacesIERC20TransferWithHttpInfo(networkId = networkId, address = address, interfacesIERC20TransferRequest = interfacesIERC20TransferRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Transfer200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.transfer
     * Write &#x60;transfer(to,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return ApiResponse<InterfacesIERC20Transfer200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20TransferWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : ApiResponse<InterfacesIERC20Transfer200Response?> {
        val localVariableConfig = interfacesIERC20TransferRequestConfig(networkId = networkId, address = address, interfacesIERC20TransferRequest = interfacesIERC20TransferRequest)

        return request<InterfacesIERC20TransferRequest, InterfacesIERC20Transfer200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20Transfer
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20TransferRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : RequestConfig<InterfacesIERC20TransferRequest> {
        val localVariableBody = interfacesIERC20TransferRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/write/{address}/transfer".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20.transferFrom
     * Write &#x60;transferFrom(from,to,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return InterfacesIERC20TransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20TransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : InterfacesIERC20TransferFrom200Response {
        val localVarResponse = interfacesIERC20TransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC20TransferFromRequest = interfacesIERC20TransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20TransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20.transferFrom
     * Write &#x60;transferFrom(from,to,amount)&#x60; on an instance of &#x60;IERC20&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return ApiResponse<InterfacesIERC20TransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20TransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : ApiResponse<InterfacesIERC20TransferFrom200Response?> {
        val localVariableConfig = interfacesIERC20TransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC20TransferFromRequest = interfacesIERC20TransferFromRequest)

        return request<InterfacesIERC20TransferFromRequest, InterfacesIERC20TransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20TransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20TransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : RequestConfig<InterfacesIERC20TransferFromRequest> {
        val localVariableBody = interfacesIERC20TransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20/write/{address}/transferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
