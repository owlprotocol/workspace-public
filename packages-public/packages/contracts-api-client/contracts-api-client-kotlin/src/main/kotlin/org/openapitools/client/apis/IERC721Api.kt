/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.DeployBeaconProxyDefaultResponse
import org.openapitools.client.models.InterfacesIERC165SupportsInterface200Response
import org.openapitools.client.models.InterfacesIERC165SupportsInterfaceRequest
import org.openapitools.client.models.InterfacesIERC721Approve200Response
import org.openapitools.client.models.InterfacesIERC721ApproveRequest
import org.openapitools.client.models.InterfacesIERC721BalanceOf200Response
import org.openapitools.client.models.InterfacesIERC721BalanceOfRequest
import org.openapitools.client.models.InterfacesIERC721GetApproved200Response
import org.openapitools.client.models.InterfacesIERC721GetApprovedRequest
import org.openapitools.client.models.InterfacesIERC721IsApprovedForAll200Response
import org.openapitools.client.models.InterfacesIERC721IsApprovedForAllRequest
import org.openapitools.client.models.InterfacesIERC721OwnerOf200Response
import org.openapitools.client.models.InterfacesIERC721SafeTransferFrom200Response
import org.openapitools.client.models.InterfacesIERC721SafeTransferFromRequest
import org.openapitools.client.models.InterfacesIERC721SetApprovalForAll200Response
import org.openapitools.client.models.InterfacesIERC721SetApprovalForAllRequest
import org.openapitools.client.models.InterfacesIERC721TransferFrom200Response
import org.openapitools.client.models.InterfacesIERC721TransferFromRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class IERC721Api(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://17a0-195-175-28-162.ngrok-free.app/api")
        }
    }

    /**
     * IERC721.approve
     * Write &#x60;approve(to,tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return InterfacesIERC721Approve200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721Approve(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : InterfacesIERC721Approve200Response {
        val localVarResponse = interfacesIERC721ApproveWithHttpInfo(networkId = networkId, address = address, interfacesIERC721ApproveRequest = interfacesIERC721ApproveRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721Approve200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.approve
     * Write &#x60;approve(to,tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return ApiResponse<InterfacesIERC721Approve200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721ApproveWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : ApiResponse<InterfacesIERC721Approve200Response?> {
        val localVariableConfig = interfacesIERC721ApproveRequestConfig(networkId = networkId, address = address, interfacesIERC721ApproveRequest = interfacesIERC721ApproveRequest)

        return request<InterfacesIERC721ApproveRequest, InterfacesIERC721Approve200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721Approve
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721ApproveRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : RequestConfig<InterfacesIERC721ApproveRequest> {
        val localVariableBody = interfacesIERC721ApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/write/{address}/approve".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.balanceOf
     * Read &#x60;balanceOf(owner)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return InterfacesIERC721BalanceOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721BalanceOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : InterfacesIERC721BalanceOf200Response {
        val localVarResponse = interfacesIERC721BalanceOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC721BalanceOfRequest = interfacesIERC721BalanceOfRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721BalanceOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.balanceOf
     * Read &#x60;balanceOf(owner)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return ApiResponse<InterfacesIERC721BalanceOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721BalanceOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : ApiResponse<InterfacesIERC721BalanceOf200Response?> {
        val localVariableConfig = interfacesIERC721BalanceOfRequestConfig(networkId = networkId, address = address, interfacesIERC721BalanceOfRequest = interfacesIERC721BalanceOfRequest)

        return request<InterfacesIERC721BalanceOfRequest, InterfacesIERC721BalanceOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721BalanceOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721BalanceOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : RequestConfig<InterfacesIERC721BalanceOfRequest> {
        val localVariableBody = interfacesIERC721BalanceOfRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/read/{address}/balanceOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.getApproved
     * Read &#x60;getApproved(tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return InterfacesIERC721GetApproved200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721GetApproved(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : InterfacesIERC721GetApproved200Response {
        val localVarResponse = interfacesIERC721GetApprovedWithHttpInfo(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721GetApproved200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.getApproved
     * Read &#x60;getApproved(tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return ApiResponse<InterfacesIERC721GetApproved200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721GetApprovedWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : ApiResponse<InterfacesIERC721GetApproved200Response?> {
        val localVariableConfig = interfacesIERC721GetApprovedRequestConfig(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return request<InterfacesIERC721GetApprovedRequest, InterfacesIERC721GetApproved200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721GetApproved
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721GetApprovedRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : RequestConfig<InterfacesIERC721GetApprovedRequest> {
        val localVariableBody = interfacesIERC721GetApprovedRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/read/{address}/getApproved".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.isApprovedForAll
     * Read &#x60;isApprovedForAll(owner,operator)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return InterfacesIERC721IsApprovedForAll200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721IsApprovedForAll(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : InterfacesIERC721IsApprovedForAll200Response {
        val localVarResponse = interfacesIERC721IsApprovedForAllWithHttpInfo(networkId = networkId, address = address, interfacesIERC721IsApprovedForAllRequest = interfacesIERC721IsApprovedForAllRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721IsApprovedForAll200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.isApprovedForAll
     * Read &#x60;isApprovedForAll(owner,operator)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return ApiResponse<InterfacesIERC721IsApprovedForAll200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721IsApprovedForAllWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : ApiResponse<InterfacesIERC721IsApprovedForAll200Response?> {
        val localVariableConfig = interfacesIERC721IsApprovedForAllRequestConfig(networkId = networkId, address = address, interfacesIERC721IsApprovedForAllRequest = interfacesIERC721IsApprovedForAllRequest)

        return request<InterfacesIERC721IsApprovedForAllRequest, InterfacesIERC721IsApprovedForAll200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721IsApprovedForAll
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721IsApprovedForAllRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : RequestConfig<InterfacesIERC721IsApprovedForAllRequest> {
        val localVariableBody = interfacesIERC721IsApprovedForAllRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/read/{address}/isApprovedForAll".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.ownerOf
     * Read &#x60;ownerOf(tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return InterfacesIERC721OwnerOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721OwnerOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : InterfacesIERC721OwnerOf200Response {
        val localVarResponse = interfacesIERC721OwnerOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721OwnerOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.ownerOf
     * Read &#x60;ownerOf(tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return ApiResponse<InterfacesIERC721OwnerOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721OwnerOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : ApiResponse<InterfacesIERC721OwnerOf200Response?> {
        val localVariableConfig = interfacesIERC721OwnerOfRequestConfig(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return request<InterfacesIERC721GetApprovedRequest, InterfacesIERC721OwnerOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721OwnerOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721OwnerOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : RequestConfig<InterfacesIERC721GetApprovedRequest> {
        val localVariableBody = interfacesIERC721GetApprovedRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/read/{address}/ownerOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.safeTransferFrom
     * Write &#x60;safeTransferFrom(from,to,tokenId,data)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return InterfacesIERC721SafeTransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721SafeTransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : InterfacesIERC721SafeTransferFrom200Response {
        val localVarResponse = interfacesIERC721SafeTransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC721SafeTransferFromRequest = interfacesIERC721SafeTransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721SafeTransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.safeTransferFrom
     * Write &#x60;safeTransferFrom(from,to,tokenId,data)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return ApiResponse<InterfacesIERC721SafeTransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721SafeTransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : ApiResponse<InterfacesIERC721SafeTransferFrom200Response?> {
        val localVariableConfig = interfacesIERC721SafeTransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC721SafeTransferFromRequest = interfacesIERC721SafeTransferFromRequest)

        return request<InterfacesIERC721SafeTransferFromRequest, InterfacesIERC721SafeTransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721SafeTransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721SafeTransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : RequestConfig<InterfacesIERC721SafeTransferFromRequest> {
        val localVariableBody = interfacesIERC721SafeTransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/write/{address}/safeTransferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.setApprovalForAll
     * Write &#x60;setApprovalForAll(operator,_approved)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return InterfacesIERC721SetApprovalForAll200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721SetApprovalForAll(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : InterfacesIERC721SetApprovalForAll200Response {
        val localVarResponse = interfacesIERC721SetApprovalForAllWithHttpInfo(networkId = networkId, address = address, interfacesIERC721SetApprovalForAllRequest = interfacesIERC721SetApprovalForAllRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721SetApprovalForAll200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.setApprovalForAll
     * Write &#x60;setApprovalForAll(operator,_approved)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return ApiResponse<InterfacesIERC721SetApprovalForAll200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721SetApprovalForAllWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : ApiResponse<InterfacesIERC721SetApprovalForAll200Response?> {
        val localVariableConfig = interfacesIERC721SetApprovalForAllRequestConfig(networkId = networkId, address = address, interfacesIERC721SetApprovalForAllRequest = interfacesIERC721SetApprovalForAllRequest)

        return request<InterfacesIERC721SetApprovalForAllRequest, InterfacesIERC721SetApprovalForAll200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721SetApprovalForAll
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721SetApprovalForAllRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : RequestConfig<InterfacesIERC721SetApprovalForAllRequest> {
        val localVariableBody = interfacesIERC721SetApprovalForAllRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/write/{address}/setApprovalForAll".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.supportsInterface
     * Read &#x60;supportsInterface(interfaceId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return InterfacesIERC165SupportsInterface200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721SupportsInterface(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : InterfacesIERC165SupportsInterface200Response {
        val localVarResponse = interfacesIERC721SupportsInterfaceWithHttpInfo(networkId = networkId, address = address, interfacesIERC165SupportsInterfaceRequest = interfacesIERC165SupportsInterfaceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC165SupportsInterface200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.supportsInterface
     * Read &#x60;supportsInterface(interfaceId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return ApiResponse<InterfacesIERC165SupportsInterface200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721SupportsInterfaceWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : ApiResponse<InterfacesIERC165SupportsInterface200Response?> {
        val localVariableConfig = interfacesIERC721SupportsInterfaceRequestConfig(networkId = networkId, address = address, interfacesIERC165SupportsInterfaceRequest = interfacesIERC165SupportsInterfaceRequest)

        return request<InterfacesIERC165SupportsInterfaceRequest, InterfacesIERC165SupportsInterface200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721SupportsInterface
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721SupportsInterfaceRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : RequestConfig<InterfacesIERC165SupportsInterfaceRequest> {
        val localVariableBody = interfacesIERC165SupportsInterfaceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/read/{address}/supportsInterface".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721.transferFrom
     * Write &#x60;transferFrom(from,to,tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return InterfacesIERC721TransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721TransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : InterfacesIERC721TransferFrom200Response {
        val localVarResponse = interfacesIERC721TransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC721TransferFromRequest = interfacesIERC721TransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721TransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721.transferFrom
     * Write &#x60;transferFrom(from,to,tokenId)&#x60; on an instance of &#x60;IERC721&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return ApiResponse<InterfacesIERC721TransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721TransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : ApiResponse<InterfacesIERC721TransferFrom200Response?> {
        val localVariableConfig = interfacesIERC721TransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC721TransferFromRequest = interfacesIERC721TransferFromRequest)

        return request<InterfacesIERC721TransferFromRequest, InterfacesIERC721TransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721TransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721TransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : RequestConfig<InterfacesIERC721TransferFromRequest> {
        val localVariableBody = interfacesIERC721TransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721/write/{address}/transferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
