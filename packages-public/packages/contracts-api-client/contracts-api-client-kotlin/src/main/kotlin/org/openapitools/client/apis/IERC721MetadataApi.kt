/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.DeployBeaconProxyDefaultResponse
import org.openapitools.client.models.InterfacesIBeaconImplementationRequest
import org.openapitools.client.models.InterfacesIContractURIContractURI200Response
import org.openapitools.client.models.InterfacesIERC165SupportsInterface200Response
import org.openapitools.client.models.InterfacesIERC165SupportsInterfaceRequest
import org.openapitools.client.models.InterfacesIERC721Approve200Response
import org.openapitools.client.models.InterfacesIERC721ApproveRequest
import org.openapitools.client.models.InterfacesIERC721BalanceOf200Response
import org.openapitools.client.models.InterfacesIERC721BalanceOfRequest
import org.openapitools.client.models.InterfacesIERC721GetApproved200Response
import org.openapitools.client.models.InterfacesIERC721GetApprovedRequest
import org.openapitools.client.models.InterfacesIERC721IsApprovedForAll200Response
import org.openapitools.client.models.InterfacesIERC721IsApprovedForAllRequest
import org.openapitools.client.models.InterfacesIERC721MetadataTokenURI200Response
import org.openapitools.client.models.InterfacesIERC721OwnerOf200Response
import org.openapitools.client.models.InterfacesIERC721SafeTransferFrom200Response
import org.openapitools.client.models.InterfacesIERC721SafeTransferFromRequest
import org.openapitools.client.models.InterfacesIERC721SetApprovalForAll200Response
import org.openapitools.client.models.InterfacesIERC721SetApprovalForAllRequest
import org.openapitools.client.models.InterfacesIERC721TransferFrom200Response
import org.openapitools.client.models.InterfacesIERC721TransferFromRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class IERC721MetadataApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://17a0-195-175-28-162.ngrok-free.app/api")
        }
    }

    /**
     * IERC721Metadata.approve
     * Write &#x60;approve(to,tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return InterfacesIERC721Approve200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataApprove(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : InterfacesIERC721Approve200Response {
        val localVarResponse = interfacesIERC721MetadataApproveWithHttpInfo(networkId = networkId, address = address, interfacesIERC721ApproveRequest = interfacesIERC721ApproveRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721Approve200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.approve
     * Write &#x60;approve(to,tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return ApiResponse<InterfacesIERC721Approve200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataApproveWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : ApiResponse<InterfacesIERC721Approve200Response?> {
        val localVariableConfig = interfacesIERC721MetadataApproveRequestConfig(networkId = networkId, address = address, interfacesIERC721ApproveRequest = interfacesIERC721ApproveRequest)

        return request<InterfacesIERC721ApproveRequest, InterfacesIERC721Approve200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataApprove
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721ApproveRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataApproveRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721ApproveRequest: InterfacesIERC721ApproveRequest) : RequestConfig<InterfacesIERC721ApproveRequest> {
        val localVariableBody = interfacesIERC721ApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/write/{address}/approve".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.balanceOf
     * Read &#x60;balanceOf(owner)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return InterfacesIERC721BalanceOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataBalanceOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : InterfacesIERC721BalanceOf200Response {
        val localVarResponse = interfacesIERC721MetadataBalanceOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC721BalanceOfRequest = interfacesIERC721BalanceOfRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721BalanceOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.balanceOf
     * Read &#x60;balanceOf(owner)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return ApiResponse<InterfacesIERC721BalanceOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataBalanceOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : ApiResponse<InterfacesIERC721BalanceOf200Response?> {
        val localVariableConfig = interfacesIERC721MetadataBalanceOfRequestConfig(networkId = networkId, address = address, interfacesIERC721BalanceOfRequest = interfacesIERC721BalanceOfRequest)

        return request<InterfacesIERC721BalanceOfRequest, InterfacesIERC721BalanceOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataBalanceOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721BalanceOfRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataBalanceOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721BalanceOfRequest: InterfacesIERC721BalanceOfRequest) : RequestConfig<InterfacesIERC721BalanceOfRequest> {
        val localVariableBody = interfacesIERC721BalanceOfRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/balanceOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.getApproved
     * Read &#x60;getApproved(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return InterfacesIERC721GetApproved200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataGetApproved(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : InterfacesIERC721GetApproved200Response {
        val localVarResponse = interfacesIERC721MetadataGetApprovedWithHttpInfo(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721GetApproved200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.getApproved
     * Read &#x60;getApproved(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return ApiResponse<InterfacesIERC721GetApproved200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataGetApprovedWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : ApiResponse<InterfacesIERC721GetApproved200Response?> {
        val localVariableConfig = interfacesIERC721MetadataGetApprovedRequestConfig(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return request<InterfacesIERC721GetApprovedRequest, InterfacesIERC721GetApproved200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataGetApproved
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataGetApprovedRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : RequestConfig<InterfacesIERC721GetApprovedRequest> {
        val localVariableBody = interfacesIERC721GetApprovedRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/getApproved".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.isApprovedForAll
     * Read &#x60;isApprovedForAll(owner,operator)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return InterfacesIERC721IsApprovedForAll200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataIsApprovedForAll(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : InterfacesIERC721IsApprovedForAll200Response {
        val localVarResponse = interfacesIERC721MetadataIsApprovedForAllWithHttpInfo(networkId = networkId, address = address, interfacesIERC721IsApprovedForAllRequest = interfacesIERC721IsApprovedForAllRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721IsApprovedForAll200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.isApprovedForAll
     * Read &#x60;isApprovedForAll(owner,operator)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return ApiResponse<InterfacesIERC721IsApprovedForAll200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataIsApprovedForAllWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : ApiResponse<InterfacesIERC721IsApprovedForAll200Response?> {
        val localVariableConfig = interfacesIERC721MetadataIsApprovedForAllRequestConfig(networkId = networkId, address = address, interfacesIERC721IsApprovedForAllRequest = interfacesIERC721IsApprovedForAllRequest)

        return request<InterfacesIERC721IsApprovedForAllRequest, InterfacesIERC721IsApprovedForAll200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataIsApprovedForAll
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721IsApprovedForAllRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataIsApprovedForAllRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721IsApprovedForAllRequest: InterfacesIERC721IsApprovedForAllRequest) : RequestConfig<InterfacesIERC721IsApprovedForAllRequest> {
        val localVariableBody = interfacesIERC721IsApprovedForAllRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/isApprovedForAll".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.name
     * Read &#x60;name()&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIContractURIContractURI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataName(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIContractURIContractURI200Response {
        val localVarResponse = interfacesIERC721MetadataNameWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIContractURIContractURI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.name
     * Read &#x60;name()&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIContractURIContractURI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataNameWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIContractURIContractURI200Response?> {
        val localVariableConfig = interfacesIERC721MetadataNameRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIContractURIContractURI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataName
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataNameRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/name".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.ownerOf
     * Read &#x60;ownerOf(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return InterfacesIERC721OwnerOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataOwnerOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : InterfacesIERC721OwnerOf200Response {
        val localVarResponse = interfacesIERC721MetadataOwnerOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721OwnerOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.ownerOf
     * Read &#x60;ownerOf(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return ApiResponse<InterfacesIERC721OwnerOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataOwnerOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : ApiResponse<InterfacesIERC721OwnerOf200Response?> {
        val localVariableConfig = interfacesIERC721MetadataOwnerOfRequestConfig(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return request<InterfacesIERC721GetApprovedRequest, InterfacesIERC721OwnerOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataOwnerOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataOwnerOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : RequestConfig<InterfacesIERC721GetApprovedRequest> {
        val localVariableBody = interfacesIERC721GetApprovedRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/ownerOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.safeTransferFrom
     * Write &#x60;safeTransferFrom(from,to,tokenId,data)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return InterfacesIERC721SafeTransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataSafeTransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : InterfacesIERC721SafeTransferFrom200Response {
        val localVarResponse = interfacesIERC721MetadataSafeTransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC721SafeTransferFromRequest = interfacesIERC721SafeTransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721SafeTransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.safeTransferFrom
     * Write &#x60;safeTransferFrom(from,to,tokenId,data)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return ApiResponse<InterfacesIERC721SafeTransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataSafeTransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : ApiResponse<InterfacesIERC721SafeTransferFrom200Response?> {
        val localVariableConfig = interfacesIERC721MetadataSafeTransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC721SafeTransferFromRequest = interfacesIERC721SafeTransferFromRequest)

        return request<InterfacesIERC721SafeTransferFromRequest, InterfacesIERC721SafeTransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataSafeTransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SafeTransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataSafeTransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SafeTransferFromRequest: InterfacesIERC721SafeTransferFromRequest) : RequestConfig<InterfacesIERC721SafeTransferFromRequest> {
        val localVariableBody = interfacesIERC721SafeTransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/write/{address}/safeTransferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.setApprovalForAll
     * Write &#x60;setApprovalForAll(operator,_approved)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return InterfacesIERC721SetApprovalForAll200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataSetApprovalForAll(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : InterfacesIERC721SetApprovalForAll200Response {
        val localVarResponse = interfacesIERC721MetadataSetApprovalForAllWithHttpInfo(networkId = networkId, address = address, interfacesIERC721SetApprovalForAllRequest = interfacesIERC721SetApprovalForAllRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721SetApprovalForAll200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.setApprovalForAll
     * Write &#x60;setApprovalForAll(operator,_approved)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return ApiResponse<InterfacesIERC721SetApprovalForAll200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataSetApprovalForAllWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : ApiResponse<InterfacesIERC721SetApprovalForAll200Response?> {
        val localVariableConfig = interfacesIERC721MetadataSetApprovalForAllRequestConfig(networkId = networkId, address = address, interfacesIERC721SetApprovalForAllRequest = interfacesIERC721SetApprovalForAllRequest)

        return request<InterfacesIERC721SetApprovalForAllRequest, InterfacesIERC721SetApprovalForAll200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataSetApprovalForAll
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721SetApprovalForAllRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataSetApprovalForAllRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721SetApprovalForAllRequest: InterfacesIERC721SetApprovalForAllRequest) : RequestConfig<InterfacesIERC721SetApprovalForAllRequest> {
        val localVariableBody = interfacesIERC721SetApprovalForAllRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/write/{address}/setApprovalForAll".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.supportsInterface
     * Read &#x60;supportsInterface(interfaceId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return InterfacesIERC165SupportsInterface200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataSupportsInterface(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : InterfacesIERC165SupportsInterface200Response {
        val localVarResponse = interfacesIERC721MetadataSupportsInterfaceWithHttpInfo(networkId = networkId, address = address, interfacesIERC165SupportsInterfaceRequest = interfacesIERC165SupportsInterfaceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC165SupportsInterface200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.supportsInterface
     * Read &#x60;supportsInterface(interfaceId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return ApiResponse<InterfacesIERC165SupportsInterface200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataSupportsInterfaceWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : ApiResponse<InterfacesIERC165SupportsInterface200Response?> {
        val localVariableConfig = interfacesIERC721MetadataSupportsInterfaceRequestConfig(networkId = networkId, address = address, interfacesIERC165SupportsInterfaceRequest = interfacesIERC165SupportsInterfaceRequest)

        return request<InterfacesIERC165SupportsInterfaceRequest, InterfacesIERC165SupportsInterface200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataSupportsInterface
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC165SupportsInterfaceRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataSupportsInterfaceRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC165SupportsInterfaceRequest: InterfacesIERC165SupportsInterfaceRequest) : RequestConfig<InterfacesIERC165SupportsInterfaceRequest> {
        val localVariableBody = interfacesIERC165SupportsInterfaceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/supportsInterface".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.symbol
     * Read &#x60;symbol()&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIContractURIContractURI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataSymbol(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIContractURIContractURI200Response {
        val localVarResponse = interfacesIERC721MetadataSymbolWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIContractURIContractURI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.symbol
     * Read &#x60;symbol()&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIContractURIContractURI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataSymbolWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIContractURIContractURI200Response?> {
        val localVariableConfig = interfacesIERC721MetadataSymbolRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIContractURIContractURI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataSymbol
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataSymbolRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/symbol".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.tokenURI
     * Read &#x60;tokenURI(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return InterfacesIERC721MetadataTokenURI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataTokenURI(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : InterfacesIERC721MetadataTokenURI200Response {
        val localVarResponse = interfacesIERC721MetadataTokenURIWithHttpInfo(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721MetadataTokenURI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.tokenURI
     * Read &#x60;tokenURI(tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return ApiResponse<InterfacesIERC721MetadataTokenURI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataTokenURIWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : ApiResponse<InterfacesIERC721MetadataTokenURI200Response?> {
        val localVariableConfig = interfacesIERC721MetadataTokenURIRequestConfig(networkId = networkId, address = address, interfacesIERC721GetApprovedRequest = interfacesIERC721GetApprovedRequest)

        return request<InterfacesIERC721GetApprovedRequest, InterfacesIERC721MetadataTokenURI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataTokenURI
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721GetApprovedRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataTokenURIRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721GetApprovedRequest: InterfacesIERC721GetApprovedRequest) : RequestConfig<InterfacesIERC721GetApprovedRequest> {
        val localVariableBody = interfacesIERC721GetApprovedRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/read/{address}/tokenURI".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC721Metadata.transferFrom
     * Write &#x60;transferFrom(from,to,tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return InterfacesIERC721TransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC721MetadataTransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : InterfacesIERC721TransferFrom200Response {
        val localVarResponse = interfacesIERC721MetadataTransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC721TransferFromRequest = interfacesIERC721TransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC721TransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC721Metadata.transferFrom
     * Write &#x60;transferFrom(from,to,tokenId)&#x60; on an instance of &#x60;IERC721Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return ApiResponse<InterfacesIERC721TransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC721MetadataTransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : ApiResponse<InterfacesIERC721TransferFrom200Response?> {
        val localVariableConfig = interfacesIERC721MetadataTransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC721TransferFromRequest = interfacesIERC721TransferFromRequest)

        return request<InterfacesIERC721TransferFromRequest, InterfacesIERC721TransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC721MetadataTransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC721TransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC721MetadataTransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC721TransferFromRequest: InterfacesIERC721TransferFromRequest) : RequestConfig<InterfacesIERC721TransferFromRequest> {
        val localVariableBody = interfacesIERC721TransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC721Metadata/write/{address}/transferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
