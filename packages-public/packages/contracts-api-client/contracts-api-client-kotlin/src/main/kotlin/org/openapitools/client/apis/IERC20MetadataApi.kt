/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.DeployBeaconProxyDefaultResponse
import org.openapitools.client.models.InterfacesIBeaconImplementationRequest
import org.openapitools.client.models.InterfacesIContractURIContractURI200Response
import org.openapitools.client.models.InterfacesIERC1820GetManagerRequest
import org.openapitools.client.models.InterfacesIERC20Allowance200Response
import org.openapitools.client.models.InterfacesIERC20AllowanceRequest
import org.openapitools.client.models.InterfacesIERC20Approve200Response
import org.openapitools.client.models.InterfacesIERC20ApproveRequest
import org.openapitools.client.models.InterfacesIERC20BalanceOf200Response
import org.openapitools.client.models.InterfacesIERC20MetadataDecimals200Response
import org.openapitools.client.models.InterfacesIERC20TotalSupply200Response
import org.openapitools.client.models.InterfacesIERC20Transfer200Response
import org.openapitools.client.models.InterfacesIERC20TransferFrom200Response
import org.openapitools.client.models.InterfacesIERC20TransferFromRequest
import org.openapitools.client.models.InterfacesIERC20TransferRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class IERC20MetadataApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://17a0-195-175-28-162.ngrok-free.app/api")
        }
    }

    /**
     * IERC20Metadata.allowance
     * Read &#x60;allowance(owner,spender)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return InterfacesIERC20Allowance200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataAllowance(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : InterfacesIERC20Allowance200Response {
        val localVarResponse = interfacesIERC20MetadataAllowanceWithHttpInfo(networkId = networkId, address = address, interfacesIERC20AllowanceRequest = interfacesIERC20AllowanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Allowance200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.allowance
     * Read &#x60;allowance(owner,spender)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return ApiResponse<InterfacesIERC20Allowance200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataAllowanceWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : ApiResponse<InterfacesIERC20Allowance200Response?> {
        val localVariableConfig = interfacesIERC20MetadataAllowanceRequestConfig(networkId = networkId, address = address, interfacesIERC20AllowanceRequest = interfacesIERC20AllowanceRequest)

        return request<InterfacesIERC20AllowanceRequest, InterfacesIERC20Allowance200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataAllowance
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20AllowanceRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataAllowanceRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20AllowanceRequest: InterfacesIERC20AllowanceRequest) : RequestConfig<InterfacesIERC20AllowanceRequest> {
        val localVariableBody = interfacesIERC20AllowanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/allowance".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.approve
     * Write &#x60;approve(spender,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return InterfacesIERC20Approve200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataApprove(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : InterfacesIERC20Approve200Response {
        val localVarResponse = interfacesIERC20MetadataApproveWithHttpInfo(networkId = networkId, address = address, interfacesIERC20ApproveRequest = interfacesIERC20ApproveRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Approve200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.approve
     * Write &#x60;approve(spender,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return ApiResponse<InterfacesIERC20Approve200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataApproveWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : ApiResponse<InterfacesIERC20Approve200Response?> {
        val localVariableConfig = interfacesIERC20MetadataApproveRequestConfig(networkId = networkId, address = address, interfacesIERC20ApproveRequest = interfacesIERC20ApproveRequest)

        return request<InterfacesIERC20ApproveRequest, InterfacesIERC20Approve200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataApprove
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20ApproveRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataApproveRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20ApproveRequest: InterfacesIERC20ApproveRequest) : RequestConfig<InterfacesIERC20ApproveRequest> {
        val localVariableBody = interfacesIERC20ApproveRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/write/{address}/approve".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.balanceOf
     * Read &#x60;balanceOf(account)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return InterfacesIERC20BalanceOf200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataBalanceOf(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : InterfacesIERC20BalanceOf200Response {
        val localVarResponse = interfacesIERC20MetadataBalanceOfWithHttpInfo(networkId = networkId, address = address, interfacesIERC1820GetManagerRequest = interfacesIERC1820GetManagerRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20BalanceOf200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.balanceOf
     * Read &#x60;balanceOf(account)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return ApiResponse<InterfacesIERC20BalanceOf200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataBalanceOfWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : ApiResponse<InterfacesIERC20BalanceOf200Response?> {
        val localVariableConfig = interfacesIERC20MetadataBalanceOfRequestConfig(networkId = networkId, address = address, interfacesIERC1820GetManagerRequest = interfacesIERC1820GetManagerRequest)

        return request<InterfacesIERC1820GetManagerRequest, InterfacesIERC20BalanceOf200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataBalanceOf
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC1820GetManagerRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataBalanceOfRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC1820GetManagerRequest: InterfacesIERC1820GetManagerRequest) : RequestConfig<InterfacesIERC1820GetManagerRequest> {
        val localVariableBody = interfacesIERC1820GetManagerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/balanceOf".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.decimals
     * Read &#x60;decimals()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIERC20MetadataDecimals200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataDecimals(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIERC20MetadataDecimals200Response {
        val localVarResponse = interfacesIERC20MetadataDecimalsWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20MetadataDecimals200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.decimals
     * Read &#x60;decimals()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIERC20MetadataDecimals200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataDecimalsWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIERC20MetadataDecimals200Response?> {
        val localVariableConfig = interfacesIERC20MetadataDecimalsRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIERC20MetadataDecimals200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataDecimals
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataDecimalsRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/decimals".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.name
     * Read &#x60;name()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIContractURIContractURI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataName(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIContractURIContractURI200Response {
        val localVarResponse = interfacesIERC20MetadataNameWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIContractURIContractURI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.name
     * Read &#x60;name()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIContractURIContractURI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataNameWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIContractURIContractURI200Response?> {
        val localVariableConfig = interfacesIERC20MetadataNameRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIContractURIContractURI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataName
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataNameRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/name".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.symbol
     * Read &#x60;symbol()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIContractURIContractURI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataSymbol(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIContractURIContractURI200Response {
        val localVarResponse = interfacesIERC20MetadataSymbolWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIContractURIContractURI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.symbol
     * Read &#x60;symbol()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIContractURIContractURI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataSymbolWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIContractURIContractURI200Response?> {
        val localVariableConfig = interfacesIERC20MetadataSymbolRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIContractURIContractURI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataSymbol
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataSymbolRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/symbol".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.totalSupply
     * Read &#x60;totalSupply()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return InterfacesIERC20TotalSupply200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataTotalSupply(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : InterfacesIERC20TotalSupply200Response {
        val localVarResponse = interfacesIERC20MetadataTotalSupplyWithHttpInfo(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20TotalSupply200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.totalSupply
     * Read &#x60;totalSupply()&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return ApiResponse<InterfacesIERC20TotalSupply200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataTotalSupplyWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : ApiResponse<InterfacesIERC20TotalSupply200Response?> {
        val localVariableConfig = interfacesIERC20MetadataTotalSupplyRequestConfig(networkId = networkId, address = address, interfacesIBeaconImplementationRequest = interfacesIBeaconImplementationRequest)

        return request<InterfacesIBeaconImplementationRequest, InterfacesIERC20TotalSupply200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataTotalSupply
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIBeaconImplementationRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataTotalSupplyRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIBeaconImplementationRequest: InterfacesIBeaconImplementationRequest) : RequestConfig<InterfacesIBeaconImplementationRequest> {
        val localVariableBody = interfacesIBeaconImplementationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/read/{address}/totalSupply".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.transfer
     * Write &#x60;transfer(to,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return InterfacesIERC20Transfer200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataTransfer(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : InterfacesIERC20Transfer200Response {
        val localVarResponse = interfacesIERC20MetadataTransferWithHttpInfo(networkId = networkId, address = address, interfacesIERC20TransferRequest = interfacesIERC20TransferRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20Transfer200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.transfer
     * Write &#x60;transfer(to,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return ApiResponse<InterfacesIERC20Transfer200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataTransferWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : ApiResponse<InterfacesIERC20Transfer200Response?> {
        val localVariableConfig = interfacesIERC20MetadataTransferRequestConfig(networkId = networkId, address = address, interfacesIERC20TransferRequest = interfacesIERC20TransferRequest)

        return request<InterfacesIERC20TransferRequest, InterfacesIERC20Transfer200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataTransfer
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataTransferRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferRequest: InterfacesIERC20TransferRequest) : RequestConfig<InterfacesIERC20TransferRequest> {
        val localVariableBody = interfacesIERC20TransferRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/write/{address}/transfer".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * IERC20Metadata.transferFrom
     * Write &#x60;transferFrom(from,to,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return InterfacesIERC20TransferFrom200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun interfacesIERC20MetadataTransferFrom(networkId: kotlin.String = "80001", address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : InterfacesIERC20TransferFrom200Response {
        val localVarResponse = interfacesIERC20MetadataTransferFromWithHttpInfo(networkId = networkId, address = address, interfacesIERC20TransferFromRequest = interfacesIERC20TransferFromRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InterfacesIERC20TransferFrom200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * IERC20Metadata.transferFrom
     * Write &#x60;transferFrom(from,to,amount)&#x60; on an instance of &#x60;IERC20Metadata&#x60;
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return ApiResponse<InterfacesIERC20TransferFrom200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun interfacesIERC20MetadataTransferFromWithHttpInfo(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : ApiResponse<InterfacesIERC20TransferFrom200Response?> {
        val localVariableConfig = interfacesIERC20MetadataTransferFromRequestConfig(networkId = networkId, address = address, interfacesIERC20TransferFromRequest = interfacesIERC20TransferFromRequest)

        return request<InterfacesIERC20TransferFromRequest, InterfacesIERC20TransferFrom200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation interfacesIERC20MetadataTransferFrom
     *
     * @param networkId The network id (default to "80001")
     * @param address An ethereum address
     * @param interfacesIERC20TransferFromRequest 
     * @return RequestConfig
     */
    fun interfacesIERC20MetadataTransferFromRequestConfig(networkId: kotlin.String, address: kotlin.String, interfacesIERC20TransferFromRequest: InterfacesIERC20TransferFromRequest) : RequestConfig<InterfacesIERC20TransferFromRequest> {
        val localVariableBody = interfacesIERC20TransferFromRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/{networkId}/interface/IERC20Metadata/write/{address}/transferFrom".replace("{"+"networkId"+"}", encodeURIComponent(networkId.toString())).replace("{"+"address"+"}", encodeURIComponent(address.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
